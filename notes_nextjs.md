# NEXTJS -  APP ROUTER

DownSides from Client - side rendering:

- needs to have JS enables in the browser (some devices might not have it).
- Not good for SEO (crawlers find only an empty html). can be done...but not easy .

NextJS :
    Added some funcitons to react so we can fetch data on the server, and return ready HTML pages to the client.
    Or we can choose if we fetch the data when the website "exits" (some loading delay).
    Or fetch the data when we compile the project, cache that HTML with the data inside, and serve that to the user when the page exists (navigate to it). That would make the display of that page superfast.

React Server Components :
    Now that React has server components ,  that has changed the field, whcih is a way a rendering react components in the server, fetch data in the server  ...so basically the same as NextJS. And they do that in a ver efficient way, so we dont need to send JS to the client.

NextJS :
Now we can decide at a component level component if it is client or server ...so inside a client component we can have server components.

Role of NextJS:
    Setup a project which uses server compnents is still hard. Nextjs gives us everything out of the box. And they add their own features: routing, image optimizatiion (very important for performance), improved server components, and a full backend functionality with API handlers, like if we had a backend with express (for data request,), ideal for small projects.
 It is still recommended by React as the way to start with server side renderering , etc.

## installation

Run `npx create-next-app@latest`:

```powershell
    What is your project named? my-app
    Would you like to use TypeScript? No / **Yes**
    Would you like to use ESLint? No / **Yes**
    Would you like to use Tailwind CSS? **No** / Yes (for this demo we use bootstrap, since library components need a bit of handling)
    Would you like to use `src/` directory? No / **Yes**
    Would you like to use App Router? (recommended) No / **Yes**
    Would you like to customize the default import alias (@/*)? **No** / Yes
    (What import alias would you like configured? @/*)

```

### initial files and special files

Now files come inside `/src/app` folder, and the file that before was `index.tsx` is now `page.tsx`.

`page.module.css` Contains the style for `page.tsx`, and thanks to **CSS modules**, those styles will only apply there.

- `layout.tsx` Name of file matters. Do not change it. This file wrapps our whole application. It replaces `__app__` and `__document__` in pages router version. Whatever we put there will be present everywhere. That makes it a very good place to put something like our **navbar**.

    We can also have nested layouts applied to certain routes, if we want.

- `const metadata=` Contains the metadata of our page.
  
```javascript
    export const metadata: Metadata = {
      title: "Create Next App",
      description: "Generated by create next app",
    };
```

Try change the title to see how changes in your browser.
This will be the global title.

- `global.css` This styles will apply to all pages.

- `const inter = Inter(...)` NextJs comes with google fonts that get downloaded in the server, so we don't need to fetch them, improving privacy and optimization, since they will come from our own server (nextjs server)

### create a new route

For that we need to create a new folder inside `/app` , and name it with the name we want for our page. If we want to render a page in `localhost:3000/hello` , we should create a `/app/hello/` folder, and inside a `page.tsx` file. Cannot be another name. In old pages router, the name of the file was part of the URL.

### Not Found page

Create `app/not-found.tsx` file, with that exact name. It will automatically be your 404 page.

```javascript
function NotFound() {
  return (
      <h1>No Page Found Here</h1>
  );
}
export default NotFound;
```

Try navigating to a non-existing route.

### loading page

Create an `app/loading.tsx` file.

```javascript
function Loading() {
  return <h2>....LOADING....</h2>;
}
export default Loading;
```

This will be the default loader component of all our app, but we can have other loaders for specific routes.
If we create a `/app/hello/loading.tsx` file,since it is inside the `/hello` folder,  that loader will appear only when we navigate to `localhost:3000/hello`.

Let's introduce some delay in our `hello` page so we can see the loader.

```javascript
async function Hello() {
  await new Promise((resolve) => {
    return setTimeout(resolve, 3000);
  });
  return (
      <h1>Hello NextJS</h1>
  );
}
export default Hello;
```

## client-server-components

This simple thing of making `async` a component it is not possible in React, and is also a change from pages router.

⚠️⚠️ by default, all components are **SERVER COMPONENTS** in NextJS. ⚠️⚠️

This means that, unless we specifiy otherwise,  the code we put before the `return()`, will only be executed on the server. Will never reach the client, so await async code, we can do API calls with credentials, etc, ... The client will get only the `return()` with the data.

Try it including a `console.log()`. Where do you see the log, in the browser's devtools or in the terminal??

❗️❗️ However, if we need interactivity and we use `useState()` , `useEffect()`, events like `onClick`, `onChange`, or acces API only availables in the browser, like the `localStorate` API, then we have to make it a ⚠️ **Client Component** .

### Client Component

Let's add an `useEffect()` to the previous component.
`useEffect()` , like other react hooks, can only be used in **client components**. In order to be able to use them without errors, we need to add the directive **`"use client"`** at the top of the component.
A client component cannot be created `async`

```javascript
"use client"
 function Hello() {
   new Promise((resolve) => {
    return setTimeout(resolve, 3000);
  });

  useEffect(()=>{},[])
  return (
      <h1>Hello NextJS</h1>
  );
}
```

When we declare a component as `"client component"` , components used inside will also be client components, but we don't need to use de `"client component"` declaraction.

Same thing will happen with a **Server Component**. Any component imported inside, will automatically be a server component, unless we declare otherwise, buy using the `"client component"` directive at the top.

```javascript
// /src/components/section.tsx
function Section() {
 console.log("client component, log displayed in console and terminal");
  return <section>Main section</section>;
}
export default Section;

// /src/app/hello/page.tsx
"use client"

function Hello() {
  return (
      <div>
      <h1>Hello NextJS</h1>
      <Section />
    </div>
  );
}
export default Hello;
```

Since `<Hello/>` it is a **client component** (as declared at the top level), `<Section/>` is also a client component, and the `console.log()`will be displayed in both terminal and console.
Try to reproduce it with `<Hello/>` as server component.

💡💡

We can consider **Server components**  as _more efficient_ (they will be rendered quicker by the broweser, and with less effort), therefore:

 In general, it would be a good idea to try to move any  `"use client"` component as "low" as possible, to where it is actually needed, and use `"use server"` the rest of the times.

💡💡

## error-page

Create a file `/src/app/error.tsx` . This will be shown when any error happens. It has to be a **client component**, therefore we have to include the `"use client"` directive.This page will only be seen in production, by the user.

This error page can also be improved via `props`

```javascript
"use client";

type ErrorProps = {
  error: Error;
  reset: () => void;
}; 

export default function error() {
  return (
    <div>
      <h1>Error page</h1>
      <h3>...something went wrong...</h3>
    </div>
  );
} 
```

The `Error` type is imported from `next/error` , and `reset` is a function given by NextJs to refresh the page so the user can remove the error (for example, if the error is produced by a server problem)

## css-framworks

<!-- //!-------?????--------- hacemos aqui lo del component para poder usar bootstrap?? ?ir a mynotes -->

## linking-navigating

Next.js give us 4 ways to navigate between routes: `<Link/>`, the h

### Link

NextJS, it is React, that means it is a SPA, therefore if we use `href="/home"` in our links, that will create a refresh that will cause a refresh of the page, reseting our state variables and losing the caching we might have. To prevent this, next gives a specific `<Link href="/home"/>` component.

```javascript
import Link from "next/link";

export default function NavBar() {
  return (
    <nav>
      <Link href="/"> Home</Link> 
    </nav>
  );
}
```

When using some _CSS Frameworks_ such as Bootstrap, Material UI, etc... , we need to tell Next to treat them as their Link element

```javascript
import Link from "next/link";
import { Nav } from "react-bootstrap";

export default function NavBar() {
  return (
    <Nav>
      <Nav.Link href="/" as={Link}> Home</Nav.Link> 
    </Nav>
  );
}
```

### hooks

Next give us the following hooks to handle navigation.

[`useRouter()`](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#userouter-hook) hook allows you to programmatically change routes from Client Components.

[`usePathName()`](https://nextjs.org/docs/app/api-reference/functions/use-pathname) is a Client Component hook that lets you read the current URL's pathname.

[`useSearchParams()`](https://nextjs.org/docs/app/api-reference/functions/use-search-params)  is a Client Component hook that lets you read the current URL's query string.

## caching

By default, in a **server component** (like our hello page ) without any extra setup, The inside of the component will be executed when we compile the project. If we happen to fetch any data there, will be put to the layout , and then Next.js will cache that generated layout in the server and will serve that page to the user until we compile our project again. ==> **SSG (Static Site Generated)**

<!-- //!-------?????--------- hacemos aqui lo de caching y production? ir a mynotes -->

## env-variables

In NextJs `.env` files are more dedicated to general or common configurations, and we put our secrets in a `.env.local`, which is _gitignored_ by default.
We create a file at the route folder of our project `projectName/.env.local`, and put your variable insde.

```javascript
API_KEY=ABC123456
```

By default, any `.env` variable we create , would be available only in a `nodeJS` enviroment, or in other words, we will be able to see it only in our termina, **not** in the browser.

If we want to make an `.env` variable available for the browser, we will have to prefix the name it with `NEXT_PUBLIC_` :

```javasript
API_KEY=iYVEO6-js2Hr7gd1M5isi1EdqIvyb-oknURl7WsLoWM
NEXT_PUBLIC_Secret=this is available also in the browser
```

The second one would only be displyed in the dev tools if it is a client component.
[env variables in Nextjs](https://nextjs.org/docs/pages/building-your-application/configuring/environment-variables)

## static-render

By default in Nextjs our components will be not only _server components_ but **static rendered**. This means that when we compile our project, Nextjs will create a page with the whole content already generated in the server, and when we hit the url, that page will be delivered to the browser and _hidrated_ (let's talk later about that).

This way, all the users will get the same information, and the render of the page will be very fast.
If we are fetching some data, that data will be fetched at build time and cached (stored in the memory of the server), so there isn't aditional fetches (requests to the API) unless with decide to _revalidate_ that request.

From [Nextjs Docs]("https://nextjs.org/docs/app/building-your-application/caching") :

```aspx-vb
Caching behavior changes depending on whether the route is statically or dynamically rendered, data is cached or uncached, and whether a request is part of an initial visit or a subsequent navigation. Depending on your use case, you can configure the caching behavior for individual routes and data requests.
```

For `fetch()` NextJS does even more, it automatically [**memoize**]("https://en.wikipedia.org/wiki/Memoization") request, so if the next requests have the same URL and Optons, instead of doing a new request, it will serve the result stored in the memory (memoized).

## dynamic-render

There might be situations in which we want Nextjs to perform the request , on the server, but eveytime the user visits the page (or refreshes it).

We have 2 main ways :

### Revalidate

We can specifiy like a _lifetime_ for the cache stored in the server. We can set a numeric value, and after that time, NextJS server, when the user visits that path, will fetch the data again and cache it.

- **Revalidate the whole component** : we can easily decide that the cache of the whole component will be deleted after some amount of time, doing a new request (fetch). [docs](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#revalidate)

```javascript
export const revalidate = 5;

export default async function Dynamic() {
  const response = await fetch(
    `https://url/api/characters`
  );
  const result = await response.json();
  return (
    <div >
    </div>
  );
}
```

In this example, the server will revalidate the whole component every 3 secons. That means that if the user visits/refreshes the page during those 5 seconds, will still get the conten cached before.

- **Revalidate a specific fetch operationt** : We can use the `revalidate` property from Next directly as an option of the `fetch()` request, giving us granular control over which request (if there were several) we want to revalidate.

```javascript
export default async function Dynamic() {
  const response = await fetch(
  `https://url/api/characters`, {next: {revalidate : 3600}}
  );
  const result = await response.json();

  return (
    <div >
    </div>
  );
}
```

The content of the fetch above will be cached for, at least, one hour (3600 seconds). That means that during that hour, our users will keep on getting the information from the fetch  stored in the cache.

Another option that would produce the same result would be :

## Opting-out of Data Chaching

We can choose not to cache the result of a fetch using the property `{cache:"no-store}"` or  `{cache:"no-cache}"` from the fetch options.

```javascript
export default async function Dynamic() {
  const response = await fetch(
   `https://url/api/whatever`, {cache :'no-store'}
  );
  const result = await response.json();
  return (
    <div >
    </div>
  );
}
```

This would produce the same effect than a `revalidate:0`.

It is word noting that if we use `revalidate:0` (or `const revalidate=0`), the component will be classified at build time by Next as _(Dynamic) server-rendered on Demand_ .

If we use `revalidate:20` (or `const revalidate=20`) with some value, will be classified at build time by Next as _(Static) prerendered as static content_ .

```json
├ ○ /_not-found                          155 B          87.2 kB
├ ƒ /dynamic-rendering                   786 B           104 kB
├ ○ /hello                               155 B          87.2 kB
├ ○ /isr                                 786 B           104 kB
└ ○ /static-rendering                    786 B           104 kB
+ First Load JS shared by all            87.1 kB
  ├ chunks/23-f5635f733efd2b7a.js        31.5 kB
  ├ chunks/fd9d1056-bd190d3f486f5748.js  53.7 kB
  └ other shared chunks (total)          1.95 kB


○  (Static)   prerendered as static content
ƒ  (Dynamic)  server-rendered on demand
```

## dynamic-url

To create a page with a dynamic URL, we will create a folder, and inside of it a subfolder with a dynamic name.

For example, if we want to render a path `localhost:3000/categories/electronics` , or a path `localhost:3000/categories/clothes`, we will create the structure :

```json
└ 📁 /app
  └ 📁 /categories
    └ 📁 /[category] 
      ├ /page.tsx
```

This way `/[category]` will be a _URL parameter_ that will take the value of path typed in the URL of the browser.

The component will have access to the URL parameter via `props`, so we can use it to fetch specific data or for other purposes.

```javascript

export default async function DynamicURL({
  params: { category },
}: PropsType) {
//....

  return (
    <div>{category}</div>
  );
}
```

## generateStaticParams

As we can see, pages generated statically in the server at build time (pre-generated and stored in the server), render incredibly fast after the first load, everytime we refresh the browser.

It is possoble to statically generate some pages in our server at build time, according to some parameters, by using `generateStaticParams()` Nextjs function.

```javascript

export function generateStaticParams() {
  return [
    { category: 'electronics'},
    { category: 'clothes'},
    { category: 'food'},
  ]
}

export default async function DynamicURL({
  params: { category },
}: PropsType) {
//....

  return (
    <div>{category}</div>
  );
}
```

In the example above, the pages `/category/electronic`,`/category/clothes` and `/category/food` will be generated in the server at build time, and served to the client very fast.
If the user visits other path not included in the array of params, it will be generated in the server on demand , needing a longer loading time.

If we don't want to accept any other segments in the URL (we want to only access `/electronic` or `/clothes` or `/food`) and give back a 404 error if we try to send a different param (IN PRODUCTION), e.g. `/category/sport`, we can use the variable `dynamicParams` [docs](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#dynamicparams) :

```javascript

export const dynamicParams = false

export function generateStaticParams() {
  return [
    { category: 'electronics'},
    { category: 'clothes'},
    { category: 'food'},
  ]
}
```

## generateMetada

Nextjs gives a way to generate metadata (information, parameters... used to add more information to the website or to get new information), by using the bult-in function `generateMetada()`, that returns an object of a predifined type `Metadata` . [docs](https://nextjs.org/docs/app/api-reference/functions/generate-metadata#generatemetadata-function)

- We can use to modify the title of our page depending the category we are fetching:

```javascript
type ParamsProps = {
  params: { category: string 
};};
// export const metadata = { title: "My Page",};  // we cannot have any hardcoded metadata in the page

export function generateMetadata({params : {category}}:ParamsProps):Metadata {
    return(
      title:category
    )
}
```

This funtion, if we choose the property `title` in the return, will automatically modify the title of the page depending on the Url's parameter.

**(add other use case here?? ....)**.

⚠️⚠️ Mind the syntax. If you use the wrong name, the function won't work and you won't get an error either.⚠️⚠️

## client-side-rendering

In React, everytime we loaded a website, the server was sending us a package with all the javascrip needed, and then the browser executed it and rendered the page. That process is what we know as **Client Side Rendering**, and it is the only type of rendering we could do in React (untill 2024, when server components where included in React 19, which was in research and development since 2020).

In Nextjs, all components are gonna use **Server Side Rendering** , unless we specify otherwise.
If we need to use the directive `"use client` . That will allow us to use all react hooks :

```javascript
"use client";

function SearchComponent() {
  const [apiResults, setApiResults] = useState<CustomType[] | null>(null);

  const handleSubmitForm = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.target as HTMLFormElement);
    const query = formData.get("search")

    const response = await fetch(`www.someApi/results?search=${query}`);
    const result: CustomType[] = await response.json();
    setApiResults(result);
  };
  return (
    <div>
      <form onSubmit={handleSubmitForm}>
          <input
            type="text"
            name="search"
            placeholder="insert something"
          />
        <button>
          Search
        </button>
      </form>
      {apiResults &&
        apiResults.map((result) => {
          return (
          <p>{result.description}</p>
          );
        })}
    </div>
  );
}

export default SearchComponent;
```

## route-handlers or API routes

Another of the advantages that Nextjs gives is the possibility of having a backend included in our client application, allowing us to build our own API without having to build an express app with Nodejs, as we did in previous project.
This is perfect for small projects in which we don't need our backend to perform really complex operations.
In Nextjs this is known as [**Route Handlers**](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), because it allow us to create request handlers for specific routes (one request handler for a GET request, another por a PUT request, etc...).

To create a _route handler_ we need to create a folder named `api` (naming convention), with a `route.tsx` file inside : `📁app/api/routeName/route.tsx`.

Inside, for every type of request (`GET`, `POST`, `PUT`, `PATCH`), we will have to build an `async` function that will receive the request made the route we created with the name of the folder.

If we we create a route handler `📁app/api/users/route.tsx` to fetch users from an external service, the endpoint to wich our client component could make the request to would be `fetch("/api/users");`

```javascript
import { APICollection } from "@/models/custom-types";
import { error } from "console";
import { NextResponse } from "next/server";

export async function GET(request: NextRequest) {

  const params = request.nextUrl.searchParams;

    const response = await fetch(
      `https://www.someApi.com/users-endpoint&api-key=${process.env.API_KEY}`
    );
    const results:CustomType = await response.json();
    return NextResponse.json(results, { status: 200 });
  
}
```

The type of the parameter `request` could be the built-in `Request` , or the extended one from Nextjs `NextRequest`.
For the response, we can also use the `Response` constructor, or the extended version provided by Vercel in `NextResponse`

## NotFound

The `notFound()` is a built-in function that allows us to render the `not-found.tsx` page.

We could use it to redirect the user there after certain response from the server (not ok, or 404).
[docs](https://nextjs.org/docs/app/api-reference/functions/not-found)

## css-module

We can solve the typical react isse with CSS scope with the use of a `css module`

We can do that by creating a css file with the name `AnyName.module.css` (better put it in the same folder as the file we want to style).

```css
.myStyle { color: red}
```

Then to use it :

```javascript
import styles from "./AnyName.module.css";

export default  function Component() {
  return (
    <div className={styles.myStyle}>
    </div>
  );
}
```

## metadata

The _metadata_ declared in `/src/layout.tsx` applies to every page, unless we specify something different.

To do that, we just need to declare again the variable `const metadata` in the `page` we want to have different metadata, and include the properties we want to modify.

This way, if in `src/hello/page.tsx` :

```javascript
export const metadata = {
  title: "Hello-Page",
};
export default async function Hello() {
//......
}
```

We can also change metadata *_dynamically_
